import { GameProject, GameConfig, GameScene } from '../types/state';

// Game visual constants
const SHOOTER_BACKGROUND_STAR_COUNT = 50;
const ARCADE_SNAKE_BASE_HUE = 120; // Green spectrum start for snake segments

/**
 * Generates playable HTML5 game code from a GameProject configuration
 */
export class GameCodeGenerator {
  
  /**
   * Generate a complete HTML5 game as a single file
   */
  static generateHTML5Game(project: GameProject): string {
    const { gameConfig, genre } = project;
    
    // Select template based on genre
    switch (genre) {
      case 'platformer':
        return this.generatePlatformerGame(project);
      case 'shooter':
        return this.generateShooterGame(project);
      case 'puzzle':
        return this.generatePuzzleGame(project);
      case 'arcade':
        return this.generateArcadeGame(project);
      case 'racing':
        return this.generateRacingGame(project);
      case 'adventure':
        return this.generateAdventureGame(project);
      default:
        return this.generateBasicGame(project);
    }
  }
  
  /**
   * Generate a platformer game
   */
  private static generatePlatformerGame(project: GameProject): string {
    const { gameConfig } = project;
    
    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${gameConfig.title || project.name}</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      display: flex; 
      justify-content: center; 
      align-items: center; 
      min-height: 100vh; 
      background: #1a1a2e;
      font-family: 'Segoe UI', sans-serif;
    }
    #gameContainer {
      position: relative;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    }
    canvas { display: block; }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-size: 16px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }
    #instructions {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255,255,255,0.7);
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <div id="ui">
      <div>Score: <span id="score">0</span></div>
      <div>Lives: <span id="lives">3</span></div>
    </div>
    <div id="instructions">Arrow Keys / WASD to move, Space to jump</div>
  </div>
  
  <script>
    // ${project.name} - Generated by Open3DStudio Game Studio
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = ${gameConfig.width};
    canvas.height = ${gameConfig.height};
    
    // Game State
    let score = 0;
    let lives = 3;
    let gameOver = false;
    
    // Player
    const player = {
      x: 100,
      y: canvas.height - 100,
      width: 40,
      height: 50,
      velocityX: 0,
      velocityY: 0,
      speed: ${gameConfig.playerConfig?.speed || 5},
      jumpPower: ${gameConfig.playerConfig?.jumpHeight || 15},
      onGround: false,
      color: '#4ecdc4'
    };
    
    // Platforms
    const platforms = [
      { x: 0, y: canvas.height - 20, width: canvas.width, height: 20, color: '#45b7d1' },
      { x: 200, y: canvas.height - 100, width: 150, height: 20, color: '#45b7d1' },
      { x: 450, y: canvas.height - 180, width: 150, height: 20, color: '#45b7d1' },
      { x: 100, y: canvas.height - 260, width: 150, height: 20, color: '#45b7d1' },
      { x: 350, y: canvas.height - 340, width: 200, height: 20, color: '#45b7d1' }
    ];
    
    // Collectibles
    const collectibles = [
      { x: 250, y: canvas.height - 130, width: 20, height: 20, collected: false },
      { x: 500, y: canvas.height - 210, width: 20, height: 20, collected: false },
      { x: 150, y: canvas.height - 290, width: 20, height: 20, collected: false },
      { x: 450, y: canvas.height - 370, width: 20, height: 20, collected: false }
    ];
    
    // Input handling
    const keys = {};
    document.addEventListener('keydown', e => keys[e.code] = true);
    document.addEventListener('keyup', e => keys[e.code] = false);
    
    // Touch controls for mobile
    let touchStartX = 0;
    canvas.addEventListener('touchstart', e => {
      touchStartX = e.touches[0].clientX;
      if (player.onGround) player.velocityY = -player.jumpPower;
    });
    canvas.addEventListener('touchmove', e => {
      const touchX = e.touches[0].clientX;
      const diff = touchX - touchStartX;
      player.velocityX = diff * 0.1;
    });
    canvas.addEventListener('touchend', () => {
      player.velocityX = 0;
    });
    
    // Physics
    const gravity = 0.6;
    const friction = 0.8;
    
    function update() {
      if (gameOver) return;
      
      // Horizontal movement
      if (keys['ArrowLeft'] || keys['KeyA']) {
        player.velocityX = -player.speed;
      } else if (keys['ArrowRight'] || keys['KeyD']) {
        player.velocityX = player.speed;
      } else {
        player.velocityX *= friction;
      }
      
      // Jumping
      if ((keys['Space'] || keys['ArrowUp'] || keys['KeyW']) && player.onGround) {
        player.velocityY = -player.jumpPower;
        player.onGround = false;
      }
      
      // Apply gravity
      player.velocityY += gravity;
      
      // Update position
      player.x += player.velocityX;
      player.y += player.velocityY;
      
      // Platform collision
      player.onGround = false;
      platforms.forEach(platform => {
        if (player.x < platform.x + platform.width &&
            player.x + player.width > platform.x &&
            player.y < platform.y + platform.height &&
            player.y + player.height > platform.y) {
          
          // Landing on top
          if (player.velocityY > 0 && player.y + player.height - player.velocityY <= platform.y) {
            player.y = platform.y - player.height;
            player.velocityY = 0;
            player.onGround = true;
          }
        }
      });
      
      // Collectible collision
      collectibles.forEach(item => {
        if (!item.collected &&
            player.x < item.x + item.width &&
            player.x + player.width > item.x &&
            player.y < item.y + item.height &&
            player.y + player.height > item.y) {
          item.collected = true;
          score += 100;
          document.getElementById('score').textContent = score;
        }
      });
      
      // Boundary check
      if (player.x < 0) player.x = 0;
      if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
      
      // Fall off screen
      if (player.y > canvas.height) {
        lives--;
        document.getElementById('lives').textContent = lives;
        if (lives <= 0) {
          gameOver = true;
        } else {
          player.x = 100;
          player.y = canvas.height - 100;
          player.velocityY = 0;
        }
      }
    }
    
    function draw() {
      // Clear canvas
      ctx.fillStyle = '${gameConfig.backgroundColor}';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw platforms
      platforms.forEach(platform => {
        ctx.fillStyle = platform.color;
        ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
      });
      
      // Draw collectibles
      ctx.fillStyle = '#ffd93d';
      collectibles.forEach(item => {
        if (!item.collected) {
          ctx.beginPath();
          ctx.arc(item.x + item.width/2, item.y + item.height/2, item.width/2, 0, Math.PI * 2);
          ctx.fill();
        }
      });
      
      // Draw player
      ctx.fillStyle = player.color;
      ctx.fillRect(player.x, player.y, player.width, player.height);
      
      // Draw eyes
      ctx.fillStyle = 'white';
      ctx.fillRect(player.x + 8, player.y + 10, 8, 8);
      ctx.fillRect(player.x + 24, player.y + 10, 8, 8);
      ctx.fillStyle = 'black';
      ctx.fillRect(player.x + 10, player.y + 12, 4, 4);
      ctx.fillRect(player.x + 26, player.y + 12, 4, 4);
      
      // Game over screen
      if (gameOver) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'white';
        ctx.font = 'bold 48px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2);
        ctx.font = '24px sans-serif';
        ctx.fillText('Score: ' + score, canvas.width/2, canvas.height/2 + 40);
        ctx.fillText('Click to restart', canvas.width/2, canvas.height/2 + 80);
      }
    }
    
    // Restart game
    canvas.addEventListener('click', () => {
      if (gameOver) {
        gameOver = false;
        score = 0;
        lives = 3;
        player.x = 100;
        player.y = canvas.height - 100;
        player.velocityY = 0;
        collectibles.forEach(item => item.collected = false);
        document.getElementById('score').textContent = score;
        document.getElementById('lives').textContent = lives;
      }
    });
    
    // Game loop
    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }
    
    gameLoop();
  </script>
</body>
</html>`;
  }
  
  /**
   * Generate a shooter game
   */
  private static generateShooterGame(project: GameProject): string {
    const { gameConfig } = project;
    
    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${gameConfig.title || project.name}</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      display: flex; 
      justify-content: center; 
      align-items: center; 
      min-height: 100vh; 
      background: #0f0f23;
      font-family: 'Segoe UI', sans-serif;
    }
    #gameContainer {
      position: relative;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    }
    canvas { display: block; background: #000; }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #0ff;
      font-size: 16px;
      text-shadow: 0 0 10px #0ff;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <div id="ui">
      <div>Score: <span id="score">0</span></div>
      <div>Wave: <span id="wave">1</span></div>
    </div>
  </div>
  
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = ${gameConfig.width};
    canvas.height = ${gameConfig.height};
    
    let score = 0;
    let wave = 1;
    let gameOver = false;
    
    // Player spaceship
    const player = {
      x: canvas.width / 2 - 25,
      y: canvas.height - 80,
      width: 50,
      height: 50,
      speed: 7,
      color: '#0ff'
    };
    
    // Bullets and enemies
    const bullets = [];
    const enemies = [];
    const particles = [];
    
    // Input
    const keys = {};
    document.addEventListener('keydown', e => {
      keys[e.code] = true;
      if (e.code === 'Space') shoot();
    });
    document.addEventListener('keyup', e => keys[e.code] = false);
    
    // Mouse/touch controls
    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      player.x = e.clientX - rect.left - player.width / 2;
    });
    canvas.addEventListener('click', shoot);
    
    function shoot() {
      if (gameOver) return;
      bullets.push({
        x: player.x + player.width / 2 - 3,
        y: player.y,
        width: 6,
        height: 15,
        speed: 10
      });
    }
    
    function spawnEnemies() {
      const count = 3 + wave;
      for (let i = 0; i < count; i++) {
        enemies.push({
          x: Math.random() * (canvas.width - 40),
          y: -50 - Math.random() * 200,
          width: 40,
          height: 40,
          speed: 1 + wave * 0.3,
          color: \`hsl(${Math.random() * 60 + 300}, 70%, 50%)\`
        });
      }
    }
    
    function createExplosion(x, y, color) {
      for (let i = 0; i < 15; i++) {
        particles.push({
          x, y,
          vx: (Math.random() - 0.5) * 8,
          vy: (Math.random() - 0.5) * 8,
          life: 30,
          color
        });
      }
    }
    
    function update() {
      if (gameOver) return;
      
      // Player movement
      if (keys['ArrowLeft'] || keys['KeyA']) player.x -= player.speed;
      if (keys['ArrowRight'] || keys['KeyD']) player.x += player.speed;
      player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
      
      // Bullets
      bullets.forEach((bullet, i) => {
        bullet.y -= bullet.speed;
        if (bullet.y < -20) bullets.splice(i, 1);
      });
      
      // Enemies
      enemies.forEach((enemy, ei) => {
        enemy.y += enemy.speed;
        
        // Hit player
        if (enemy.y + enemy.height > player.y &&
            enemy.x < player.x + player.width &&
            enemy.x + enemy.width > player.x) {
          gameOver = true;
          createExplosion(player.x + player.width/2, player.y + player.height/2, player.color);
        }
        
        // Check bullet collision
        bullets.forEach((bullet, bi) => {
          if (bullet.x < enemy.x + enemy.width &&
              bullet.x + bullet.width > enemy.x &&
              bullet.y < enemy.y + enemy.height &&
              bullet.y + bullet.height > enemy.y) {
            createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2, enemy.color);
            enemies.splice(ei, 1);
            bullets.splice(bi, 1);
            score += 10;
            document.getElementById('score').textContent = score;
          }
        });
        
        if (enemy.y > canvas.height) enemies.splice(ei, 1);
      });
      
      // Particles
      particles.forEach((p, i) => {
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
      });
      
      // Spawn new wave
      if (enemies.length === 0) {
        wave++;
        document.getElementById('wave').textContent = wave;
        spawnEnemies();
      }
    }
    
    function draw() {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Stars background (${SHOOTER_BACKGROUND_STAR_COUNT} stars)
      ctx.fillStyle = '#fff';
      for (let i = 0; i < ${SHOOTER_BACKGROUND_STAR_COUNT}; i++) {
        ctx.fillRect(
          (i * 137 + Date.now() * 0.01) % canvas.width,
          (i * 97) % canvas.height,
          1, 1
        );
      }
      
      // Draw player
      ctx.fillStyle = player.color;
      ctx.beginPath();
      ctx.moveTo(player.x + player.width / 2, player.y);
      ctx.lineTo(player.x, player.y + player.height);
      ctx.lineTo(player.x + player.width, player.y + player.height);
      ctx.closePath();
      ctx.fill();
      
      // Draw bullets
      ctx.fillStyle = '#ff0';
      bullets.forEach(b => ctx.fillRect(b.x, b.y, b.width, b.height));
      
      // Draw enemies
      enemies.forEach(e => {
        ctx.fillStyle = e.color;
        ctx.fillRect(e.x, e.y, e.width, e.height);
      });
      
      // Draw particles
      particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life / 30;
        ctx.fillRect(p.x, p.y, 4, 4);
        ctx.globalAlpha = 1;
      });
      
      if (gameOver) {
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#f00';
        ctx.font = 'bold 48px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2);
        ctx.fillStyle = '#fff';
        ctx.font = '24px sans-serif';
        ctx.fillText('Score: ' + score, canvas.width/2, canvas.height/2 + 40);
      }
    }
    
    canvas.addEventListener('click', () => {
      if (gameOver) {
        gameOver = false;
        score = 0;
        wave = 1;
        enemies.length = 0;
        bullets.length = 0;
        player.x = canvas.width / 2 - 25;
        document.getElementById('score').textContent = 0;
        document.getElementById('wave').textContent = 1;
        spawnEnemies();
      }
    });
    
    spawnEnemies();
    
    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }
    gameLoop();
  </script>
</body>
</html>`;
  }
  
  /**
   * Generate a puzzle game
   */
  private static generatePuzzleGame(project: GameProject): string {
    const { gameConfig } = project;
    
    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${gameConfig.title || project.name}</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      display: flex; 
      justify-content: center; 
      align-items: center; 
      min-height: 100vh; 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      font-family: 'Segoe UI', sans-serif;
    }
    #game {
      background: rgba(255,255,255,0.95);
      padding: 30px;
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      text-align: center;
    }
    h1 { color: #667eea; margin-bottom: 10px; }
    #info { margin-bottom: 20px; color: #666; }
    #grid {
      display: grid;
      grid-template-columns: repeat(4, 80px);
      gap: 10px;
      margin: 20px auto;
    }
    .tile {
      width: 80px;
      height: 80px;
      background: linear-gradient(135deg, #667eea, #764ba2);
      border-radius: 15px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 28px;
      font-weight: bold;
      color: white;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 5px 15px rgba(102,126,234,0.4);
    }
    .tile:hover { transform: scale(1.05); }
    .tile.empty { 
      background: #f0f0f0; 
      box-shadow: inset 0 2px 10px rgba(0,0,0,0.1);
    }
    .tile.correct { background: linear-gradient(135deg, #11998e, #38ef7d); }
    button {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      border: none;
      padding: 15px 30px;
      border-radius: 30px;
      font-size: 16px;
      cursor: pointer;
      margin-top: 20px;
      transition: transform 0.2s;
    }
    button:hover { transform: scale(1.05); }
    #message { margin-top: 20px; font-size: 24px; color: #667eea; }
  </style>
</head>
<body>
  <div id="game">
    <h1>üß© Sliding Puzzle</h1>
    <div id="info">Moves: <span id="moves">0</span></div>
    <div id="grid"></div>
    <button onclick="shuffle()">Shuffle</button>
    <div id="message"></div>
  </div>
  
  <script>
    let tiles = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0];
    let moves = 0;
    
    function render() {
      const grid = document.getElementById('grid');
      grid.innerHTML = '';
      const solved = checkWin();
      
      tiles.forEach((num, i) => {
        const tile = document.createElement('div');
        tile.className = 'tile' + (num === 0 ? ' empty' : '') + 
                        (solved && num === i + 1 ? ' correct' : '');
        tile.textContent = num || '';
        tile.onclick = () => moveTile(i);
        grid.appendChild(tile);
      });
      
      document.getElementById('moves').textContent = moves;
      document.getElementById('message').textContent = solved ? 'üéâ Solved!' : '';
    }
    
    function moveTile(index) {
      const emptyIndex = tiles.indexOf(0);
      const row = Math.floor(index / 4);
      const col = index % 4;
      const emptyRow = Math.floor(emptyIndex / 4);
      const emptyCol = emptyIndex % 4;
      
      if ((Math.abs(row - emptyRow) === 1 && col === emptyCol) ||
          (Math.abs(col - emptyCol) === 1 && row === emptyRow)) {
        [tiles[index], tiles[emptyIndex]] = [tiles[emptyIndex], tiles[index]];
        moves++;
        render();
      }
    }
    
    function shuffle() {
      moves = 0;
      for (let i = 0; i < 100; i++) {
        const emptyIndex = tiles.indexOf(0);
        const neighbors = [];
        if (emptyIndex >= 4) neighbors.push(emptyIndex - 4);
        if (emptyIndex < 12) neighbors.push(emptyIndex + 4);
        if (emptyIndex % 4 !== 0) neighbors.push(emptyIndex - 1);
        if (emptyIndex % 4 !== 3) neighbors.push(emptyIndex + 1);
        const randomNeighbor = neighbors[Math.floor(Math.random() * neighbors.length)];
        [tiles[emptyIndex], tiles[randomNeighbor]] = [tiles[randomNeighbor], tiles[emptyIndex]];
      }
      render();
    }
    
    function checkWin() {
      for (let i = 0; i < 15; i++) {
        if (tiles[i] !== i + 1) return false;
      }
      return true;
    }
    
    render();
  </script>
</body>
</html>`;
  }
  
  /**
   * Generate an arcade game
   */
  private static generateArcadeGame(project: GameProject): string {
    const { gameConfig } = project;
    
    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${gameConfig.title || project.name}</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      display: flex; 
      justify-content: center; 
      align-items: center; 
      min-height: 100vh; 
      background: #1a1a2e;
    }
    canvas { 
      border-radius: 8px; 
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    canvas.width = ${gameConfig.width};
    canvas.height = ${gameConfig.height};
    
    // Snake game
    const gridSize = 20;
    let snake = [{x: 10, y: 10}];
    let direction = {x: 1, y: 0};
    let food = spawnFood();
    let score = 0;
    let gameOver = false;
    let speed = 100;
    let lastTime = 0;
    
    function spawnFood() {
      return {
        x: Math.floor(Math.random() * (canvas.width / gridSize)),
        y: Math.floor(Math.random() * (canvas.height / gridSize))
      };
    }
    
    document.addEventListener('keydown', e => {
      if (gameOver && e.code === 'Space') {
        snake = [{x: 10, y: 10}];
        direction = {x: 1, y: 0};
        food = spawnFood();
        score = 0;
        gameOver = false;
        return;
      }
      
      switch(e.code) {
        case 'ArrowUp': case 'KeyW':
          if (direction.y !== 1) direction = {x: 0, y: -1};
          break;
        case 'ArrowDown': case 'KeyS':
          if (direction.y !== -1) direction = {x: 0, y: 1};
          break;
        case 'ArrowLeft': case 'KeyA':
          if (direction.x !== 1) direction = {x: -1, y: 0};
          break;
        case 'ArrowRight': case 'KeyD':
          if (direction.x !== -1) direction = {x: 1, y: 0};
          break;
      }
    });
    
    function update(time) {
      if (gameOver) return;
      if (time - lastTime < speed) return;
      lastTime = time;
      
      const head = {
        x: snake[0].x + direction.x,
        y: snake[0].y + direction.y
      };
      
      // Wall collision
      if (head.x < 0 || head.x >= canvas.width / gridSize ||
          head.y < 0 || head.y >= canvas.height / gridSize) {
        gameOver = true;
        return;
      }
      
      // Self collision
      if (snake.some(s => s.x === head.x && s.y === head.y)) {
        gameOver = true;
        return;
      }
      
      snake.unshift(head);
      
      // Eat food
      if (head.x === food.x && head.y === food.y) {
        score += 10;
        food = spawnFood();
        speed = Math.max(50, speed - 2);
      } else {
        snake.pop();
      }
    }
    
    function draw() {
      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Grid
      ctx.strokeStyle = '#2a2a4e';
      for (let i = 0; i < canvas.width; i += gridSize) {
        ctx.beginPath();
        ctx.moveTo(i, 0);
        ctx.lineTo(i, canvas.height);
        ctx.stroke();
      }
      for (let i = 0; i < canvas.height; i += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, i);
        ctx.lineTo(canvas.width, i);
        ctx.stroke();
      }
      
      // Food
      ctx.fillStyle = '#ff6b6b';
      ctx.beginPath();
      ctx.arc(
        food.x * gridSize + gridSize / 2,
        food.y * gridSize + gridSize / 2,
        gridSize / 2 - 2, 0, Math.PI * 2
      );
      ctx.fill();
      
      // Snake - color gradient from green (hue ${ARCADE_SNAKE_BASE_HUE}) to yellow
      snake.forEach((segment, i) => {
        const hue = ${ARCADE_SNAKE_BASE_HUE} + i * 3;
        ctx.fillStyle = \`hsl(\${hue}, 70%, 50%)\`;
        ctx.fillRect(
          segment.x * gridSize + 1,
          segment.y * gridSize + 1,
          gridSize - 2,
          gridSize - 2
        );
      });
      
      // Score
      ctx.fillStyle = '#fff';
      ctx.font = '20px sans-serif';
      ctx.fillText('Score: ' + score, 10, 30);
      
      // Game over
      if (gameOver) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#ff6b6b';
        ctx.font = 'bold 48px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
        ctx.fillStyle = '#fff';
        ctx.font = '24px sans-serif';
        ctx.fillText('Score: ' + score, canvas.width / 2, canvas.height / 2 + 40);
        ctx.fillText('Press SPACE to restart', canvas.width / 2, canvas.height / 2 + 80);
        ctx.textAlign = 'left';
      }
    }
    
    function gameLoop(time) {
      update(time);
      draw();
      requestAnimationFrame(gameLoop);
    }
    
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>`;
  }
  
  /**
   * Generate a racing game
   */
  private static generateRacingGame(project: GameProject): string {
    const { gameConfig } = project;
    
    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${gameConfig.title || project.name}</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      display: flex; 
      justify-content: center; 
      align-items: center; 
      min-height: 100vh; 
      background: #1a1a2e;
      font-family: 'Segoe UI', sans-serif;
    }
    #gameContainer {
      position: relative;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    }
    canvas { display: block; }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #0f0;
      font-size: 16px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      font-family: monospace;
    }
    #instructions {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255,255,255,0.7);
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <div id="ui">
      <div>Speed: <span id="speed">0</span> km/h</div>
      <div>Score: <span id="score">0</span></div>
      <div>Distance: <span id="distance">0</span>m</div>
    </div>
    <div id="instructions">‚Üê ‚Üí or A/D to steer</div>
  </div>
  
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = ${gameConfig.width};
    canvas.height = ${gameConfig.height};
    
    let score = 0;
    let distance = 0;
    let speed = 0;
    let maxSpeed = 200;
    let gameOver = false;
    
    // Player car
    const player = {
      x: canvas.width / 2 - 20,
      y: canvas.height - 100,
      width: 40,
      height: 70,
      lane: 1, // 0, 1, 2
      targetX: canvas.width / 2 - 20
    };
    
    // Road properties
    const road = {
      width: 300,
      lanes: 3,
      lineHeight: 40,
      lineGap: 20,
      offset: 0
    };
    
    // Obstacles
    const obstacles = [];
    let obstacleTimer = 0;
    
    // Input
    const keys = {};
    document.addEventListener('keydown', e => keys[e.code] = true);
    document.addEventListener('keyup', e => keys[e.code] = false);
    
    function spawnObstacle() {
      const lane = Math.floor(Math.random() * 3);
      const roadLeft = (canvas.width - road.width) / 2;
      const laneWidth = road.width / 3;
      
      obstacles.push({
        x: roadLeft + lane * laneWidth + laneWidth / 2 - 20,
        y: -80,
        width: 40,
        height: 70,
        lane: lane,
        color: ['#e74c3c', '#3498db', '#f39c12'][Math.floor(Math.random() * 3)]
      });
    }
    
    function update() {
      if (gameOver) return;
      
      // Accelerate
      speed = Math.min(maxSpeed, speed + 0.5);
      distance += speed / 60;
      score = Math.floor(distance / 10);
      
      // Update UI
      document.getElementById('speed').textContent = Math.floor(speed);
      document.getElementById('score').textContent = score;
      document.getElementById('distance').textContent = Math.floor(distance);
      
      // Steering
      const roadLeft = (canvas.width - road.width) / 2;
      const laneWidth = road.width / 3;
      
      if (keys['ArrowLeft'] || keys['KeyA']) {
        player.lane = Math.max(0, player.lane - 0.05);
      }
      if (keys['ArrowRight'] || keys['KeyD']) {
        player.lane = Math.min(2, player.lane + 0.05);
      }
      
      player.targetX = roadLeft + Math.floor(player.lane) * laneWidth + laneWidth / 2 - player.width / 2;
      player.x += (player.targetX - player.x) * 0.1;
      
      // Road animation
      road.offset += speed / 10;
      if (road.offset > road.lineHeight + road.lineGap) {
        road.offset = 0;
      }
      
      // Spawn obstacles
      obstacleTimer += speed / 60;
      if (obstacleTimer > 50) {
        spawnObstacle();
        obstacleTimer = 0;
      }
      
      // Update obstacles
      obstacles.forEach((obs, i) => {
        obs.y += speed / 10;
        
        // Collision check
        if (obs.y + obs.height > player.y &&
            obs.y < player.y + player.height &&
            obs.x + obs.width > player.x &&
            obs.x < player.x + player.width) {
          gameOver = true;
        }
        
        // Remove off-screen
        if (obs.y > canvas.height) {
          obstacles.splice(i, 1);
        }
      });
    }
    
    function drawCar(x, y, width, height, color, isPlayer) {
      // Car body
      ctx.fillStyle = color;
      ctx.fillRect(x, y, width, height);
      
      // Windshield
      ctx.fillStyle = isPlayer ? '#87ceeb' : '#333';
      ctx.fillRect(x + 5, y + 10, width - 10, 20);
      
      // Wheels
      ctx.fillStyle = '#222';
      ctx.fillRect(x - 5, y + 5, 8, 15);
      ctx.fillRect(x + width - 3, y + 5, 8, 15);
      ctx.fillRect(x - 5, y + height - 20, 8, 15);
      ctx.fillRect(x + width - 3, y + height - 20, 8, 15);
    }
    
    function draw() {
      // Sky gradient
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, '#1a1a2e');
      gradient.addColorStop(1, '#16213e');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Road
      const roadLeft = (canvas.width - road.width) / 2;
      ctx.fillStyle = '#333';
      ctx.fillRect(roadLeft, 0, road.width, canvas.height);
      
      // Road edges
      ctx.fillStyle = '#fff';
      ctx.fillRect(roadLeft - 5, 0, 5, canvas.height);
      ctx.fillRect(roadLeft + road.width, 0, 5, canvas.height);
      
      // Lane markings
      ctx.fillStyle = '#fff';
      const laneWidth = road.width / 3;
      for (let i = 1; i < 3; i++) {
        for (let y = -road.lineHeight + road.offset; y < canvas.height; y += road.lineHeight + road.lineGap) {
          ctx.fillRect(roadLeft + i * laneWidth - 2, y, 4, road.lineHeight);
        }
      }
      
      // Draw obstacles
      obstacles.forEach(obs => {
        drawCar(obs.x, obs.y, obs.width, obs.height, obs.color, false);
      });
      
      // Draw player
      drawCar(player.x, player.y, player.width, player.height, '#2ecc71', true);
      
      // Game over
      if (gameOver) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#e74c3c';
        ctx.font = 'bold 48px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('CRASH!', canvas.width / 2, canvas.height / 2 - 20);
        ctx.fillStyle = '#fff';
        ctx.font = '24px sans-serif';
        ctx.fillText('Score: ' + score, canvas.width / 2, canvas.height / 2 + 20);
        ctx.fillText('Distance: ' + Math.floor(distance) + 'm', canvas.width / 2, canvas.height / 2 + 50);
        ctx.fillText('Click to restart', canvas.width / 2, canvas.height / 2 + 90);
        ctx.textAlign = 'left';
      }
    }
    
    canvas.addEventListener('click', () => {
      if (gameOver) {
        gameOver = false;
        score = 0;
        distance = 0;
        speed = 0;
        player.lane = 1;
        player.x = canvas.width / 2 - 20;
        obstacles.length = 0;
      }
    });
    
    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }
    
    gameLoop();
  </script>
</body>
</html>`;
  }
  
  /**
   * Generate an adventure game
   */
  private static generateAdventureGame(project: GameProject): string {
    const { gameConfig } = project;
    
    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${gameConfig.title || project.name}</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      display: flex; 
      justify-content: center; 
      align-items: center; 
      min-height: 100vh; 
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      font-family: 'Segoe UI', sans-serif;
    }
    #gameContainer {
      position: relative;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    }
    canvas { display: block; }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #ffd700;
      font-size: 14px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
    }
    #dialog {
      position: absolute;
      bottom: 10px;
      left: 10px;
      right: 10px;
      background: rgba(0,0,0,0.85);
      color: white;
      padding: 15px;
      border-radius: 8px;
      border: 2px solid #ffd700;
      display: none;
      font-size: 14px;
      line-height: 1.5;
    }
    #instructions {
      position: absolute;
      top: 10px;
      right: 10px;
      color: rgba(255,255,255,0.6);
      font-size: 11px;
      text-align: right;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <div id="ui">
      <div>üóùÔ∏è Keys: <span id="keys">0</span>/3</div>
      <div>üíé Gems: <span id="gems">0</span></div>
    </div>
    <div id="instructions">
      WASD/Arrows to move<br>
      E to interact
    </div>
    <div id="dialog"></div>
  </div>
  
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = ${gameConfig.width};
    canvas.height = ${gameConfig.height};
    
    const TILE_SIZE = 40;
    const COLS = Math.floor(canvas.width / TILE_SIZE);
    const ROWS = Math.floor(canvas.height / TILE_SIZE);
    
    let keys = 0;
    let gems = 0;
    let dialogText = '';
    let dialogTimer = 0;
    let gameWon = false;
    
    // Player
    const player = {
      x: TILE_SIZE * 1.5,
      y: TILE_SIZE * 1.5,
      width: 30,
      height: 30,
      speed: 3,
      color: '#4ecdc4'
    };
    
    // Map: 0=floor, 1=wall, 2=key, 3=gem, 4=npc, 5=door
    const map = [];
    const items = [];
    const npcs = [];
    
    // Generate simple dungeon
    function generateMap() {
      for (let y = 0; y < ROWS; y++) {
        map[y] = [];
        for (let x = 0; x < COLS; x++) {
          // Border walls
          if (x === 0 || y === 0 || x === COLS - 1 || y === ROWS - 1) {
            map[y][x] = 1;
          }
          // Random walls
          else if (Math.random() < 0.15 && !(x < 3 && y < 3)) {
            map[y][x] = 1;
          }
          else {
            map[y][x] = 0;
          }
        }
      }
      
      // Add door at exit
      map[ROWS - 2][COLS - 2] = 5;
      map[ROWS - 3][COLS - 2] = 0;
      
      // Add keys
      const keyPositions = [
        { x: COLS - 3, y: 2 },
        { x: 2, y: ROWS - 3 },
        { x: Math.floor(COLS / 2), y: Math.floor(ROWS / 2) }
      ];
      keyPositions.forEach(pos => {
        map[pos.y][pos.x] = 0;
        items.push({ x: pos.x * TILE_SIZE + TILE_SIZE / 2, y: pos.y * TILE_SIZE + TILE_SIZE / 2, type: 'key' });
      });
      
      // Add gems
      for (let i = 0; i < 5; i++) {
        const x = Math.floor(Math.random() * (COLS - 4)) + 2;
        const y = Math.floor(Math.random() * (ROWS - 4)) + 2;
        if (map[y][x] === 0) {
          items.push({ x: x * TILE_SIZE + TILE_SIZE / 2, y: y * TILE_SIZE + TILE_SIZE / 2, type: 'gem' });
        }
      }
      
      // Add NPC
      npcs.push({
        x: Math.floor(COLS / 2) * TILE_SIZE + TILE_SIZE / 2,
        y: 2 * TILE_SIZE + TILE_SIZE / 2,
        message: "Find all 3 keys to unlock the exit door! Good luck, adventurer!"
      });
    }
    
    generateMap();
    
    // Input
    const keysPressed = {};
    document.addEventListener('keydown', e => {
      keysPressed[e.code] = true;
      if (e.code === 'KeyE') interact();
    });
    document.addEventListener('keyup', e => keysPressed[e.code] = false);
    
    function showDialog(text) {
      dialogText = text;
      dialogTimer = 180; // 3 seconds
      document.getElementById('dialog').textContent = text;
      document.getElementById('dialog').style.display = 'block';
    }
    
    function interact() {
      // Check NPC interaction
      npcs.forEach(npc => {
        const dx = player.x + player.width / 2 - npc.x;
        const dy = player.y + player.height / 2 - npc.y;
        if (Math.sqrt(dx * dx + dy * dy) < TILE_SIZE) {
          showDialog(npc.message);
        }
      });
      
      // Check door
      const tileX = Math.floor((player.x + player.width / 2) / TILE_SIZE);
      const tileY = Math.floor((player.y + player.height / 2) / TILE_SIZE);
      if (map[tileY] && map[tileY][tileX] === 5) {
        if (keys >= 3) {
          gameWon = true;
          showDialog("üéâ Congratulations! You escaped the dungeon!");
        } else {
          showDialog("The door is locked. You need " + (3 - keys) + " more key(s).");
        }
      }
    }
    
    function update() {
      if (gameWon) return;
      
      // Movement
      let dx = 0, dy = 0;
      if (keysPressed['ArrowUp'] || keysPressed['KeyW']) dy = -player.speed;
      if (keysPressed['ArrowDown'] || keysPressed['KeyS']) dy = player.speed;
      if (keysPressed['ArrowLeft'] || keysPressed['KeyA']) dx = -player.speed;
      if (keysPressed['ArrowRight'] || keysPressed['KeyD']) dx = player.speed;
      
      // Check collision
      const newX = player.x + dx;
      const newY = player.y + dy;
      
      const checkCollision = (x, y) => {
        const corners = [
          { x: x, y: y },
          { x: x + player.width, y: y },
          { x: x, y: y + player.height },
          { x: x + player.width, y: y + player.height }
        ];
        return corners.some(c => {
          const tileX = Math.floor(c.x / TILE_SIZE);
          const tileY = Math.floor(c.y / TILE_SIZE);
          return map[tileY] && (map[tileY][tileX] === 1 || map[tileY][tileX] === 5);
        });
      };
      
      if (!checkCollision(newX, player.y)) player.x = newX;
      if (!checkCollision(player.x, newY)) player.y = newY;
      
      // Collect items
      items.forEach((item, i) => {
        const dx = player.x + player.width / 2 - item.x;
        const dy = player.y + player.height / 2 - item.y;
        if (Math.sqrt(dx * dx + dy * dy) < 20) {
          if (item.type === 'key') {
            keys++;
            showDialog("üóùÔ∏è You found a key! (" + keys + "/3)");
          } else {
            gems++;
            showDialog("üíé You found a gem!");
          }
          items.splice(i, 1);
        }
      });
      
      // Update UI
      document.getElementById('keys').textContent = keys;
      document.getElementById('gems').textContent = gems;
      
      // Dialog timer
      if (dialogTimer > 0) {
        dialogTimer--;
        if (dialogTimer === 0) {
          document.getElementById('dialog').style.display = 'none';
        }
      }
    }
    
    function draw() {
      // Clear
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw map
      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          const tile = map[y][x];
          if (tile === 1) {
            ctx.fillStyle = '#4a4a6a';
            ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            ctx.strokeStyle = '#5a5a7a';
            ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
          } else if (tile === 5) {
            ctx.fillStyle = keys >= 3 ? '#2ecc71' : '#8b4513';
            ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            ctx.fillStyle = '#ffd700';
            ctx.font = '20px sans-serif';
            ctx.fillText('üö™', x * TILE_SIZE + 8, y * TILE_SIZE + 28);
          } else {
            ctx.fillStyle = '#2a2a4a';
            ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
          }
        }
      }
      
      // Draw items
      ctx.font = '20px sans-serif';
      items.forEach(item => {
        ctx.fillText(item.type === 'key' ? 'üóùÔ∏è' : 'üíé', item.x - 10, item.y + 7);
      });
      
      // Draw NPCs
      npcs.forEach(npc => {
        ctx.fillText('üßô', npc.x - 12, npc.y + 8);
      });
      
      // Draw player
      ctx.fillStyle = player.color;
      ctx.fillRect(player.x, player.y, player.width, player.height);
      ctx.fillStyle = '#fff';
      ctx.fillRect(player.x + 6, player.y + 6, 6, 6);
      ctx.fillRect(player.x + 18, player.y + 6, 6, 6);
      
      // Win screen
      if (gameWon) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 36px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('üèÜ Victory! üèÜ', canvas.width / 2, canvas.height / 2 - 20);
        ctx.fillStyle = '#fff';
        ctx.font = '20px sans-serif';
        ctx.fillText('Gems collected: ' + gems, canvas.width / 2, canvas.height / 2 + 20);
        ctx.textAlign = 'left';
      }
    }
    
    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }
    
    showDialog("Welcome, adventurer! Find 3 keys to escape. Press E to interact.");
    gameLoop();
  </script>
</body>
</html>`;
  }
  
  /**
   * Generate a basic template game
   */
  private static generateBasicGame(project: GameProject): string {
    const { gameConfig } = project;
    
    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${gameConfig.title || project.name}</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      display: flex; 
      flex-direction: column;
      justify-content: center; 
      align-items: center; 
      min-height: 100vh; 
      background: ${gameConfig.backgroundColor};
      font-family: 'Segoe UI', sans-serif;
      color: white;
    }
    canvas { 
      border-radius: 8px; 
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
      margin-bottom: 20px;
    }
    .info {
      text-align: center;
      opacity: 0.8;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div class="info">
    <p>Use Arrow Keys or WASD to move</p>
    <p>Click to interact</p>
  </div>
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    canvas.width = ${gameConfig.width};
    canvas.height = ${gameConfig.height};
    
    // Player object
    const player = {
      x: canvas.width / 2 - 25,
      y: canvas.height / 2 - 25,
      width: 50,
      height: 50,
      speed: 5,
      color: '#4ecdc4'
    };
    
    // Input handling
    const keys = {};
    document.addEventListener('keydown', e => keys[e.code] = true);
    document.addEventListener('keyup', e => keys[e.code] = false);
    
    // Game loop
    function update() {
      if (keys['ArrowUp'] || keys['KeyW']) player.y -= player.speed;
      if (keys['ArrowDown'] || keys['KeyS']) player.y += player.speed;
      if (keys['ArrowLeft'] || keys['KeyA']) player.x -= player.speed;
      if (keys['ArrowRight'] || keys['KeyD']) player.x += player.speed;
      
      // Keep player in bounds
      player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
      player.y = Math.max(0, Math.min(canvas.height - player.height, player.y));
    }
    
    function draw() {
      // Clear canvas
      ctx.fillStyle = '${gameConfig.backgroundColor}';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw player
      ctx.fillStyle = player.color;
      ctx.fillRect(player.x, player.y, player.width, player.height);
      
      // Add some visual flair
      ctx.strokeStyle = 'rgba(255,255,255,0.3)';
      ctx.lineWidth = 2;
      ctx.strokeRect(player.x, player.y, player.width, player.height);
    }
    
    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }
    
    gameLoop();
  </script>
</body>
</html>`;
  }
  
  /**
   * Download generated game as HTML file
   */
  static downloadGame(project: GameProject): void {
    const html = this.generateHTML5Game(project);
    const blob = new Blob([html], { type: 'text/html' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${project.name.replace(/\s+/g, '_').toLowerCase()}.html`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }
  
  /**
   * Get game preview URL (data URL)
   */
  static getPreviewDataUrl(project: GameProject): string {
    const html = this.generateHTML5Game(project);
    return `data:text/html;charset=utf-8,${encodeURIComponent(html)}`;
  }
}

export default GameCodeGenerator;
